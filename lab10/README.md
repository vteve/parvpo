# Лабораторная работа 10: Оптимизация ветвлений

## Описание

Данная лабораторная работа демонстрирует влияние подсказок компилятору о вероятности ветвлений на производительность программы.

## Алгоритм

Программа выполняет неравновероятное ветвление:
- Вычисляет две суммы массива
- В `sum_rare` попадает каждое 1000-е число (0.1% случаев)
- В `sum_many` попадают все остальные числа (99.9% случаев)

## Реализации

1. **Baseline** - без подсказок компилятору
2. **Correct hint** - правильная подсказка `unlikely(i % 1000 == 0)`
3. **Wrong hint** - неправильная подсказка `likely(i % 1000 == 0)`
4. **Inverted hint** - инвертированная подсказка `!(unlikely(i % 1000 != 0))`

## Макросы

Используются макросы `likely()` и `unlikely()`:
- `likely(expr)` - подсказка, что выражение скорее всего истинно
- `unlikely(expr)` - подсказка, что выражение скорее всего ложно

Эти макросы поддерживаются в GCC, Clang и Intel Compiler.

## Шаги выполнения

### 1. Быстрый тест

```bash
# Простая компиляция и запуск
g++ -O2 -o main.exe main.cpp
./main.exe
```

### 2. Полный бенчмарк (рекомендуется)

```bash
# Автоматический запуск всех тестов с графиками
python run_benchmark.py
```

### 3. Ручная компиляция

```bash
# Компиляция с разными уровнями оптимизации
g++ -O0 -o main_O0.exe main.cpp
g++ -O1 -o main_O1.exe main.cpp
g++ -O2 -o main_O2.exe main.cpp
g++ -O3 -o main_O3.exe main.cpp
g++ -Os -o main_Os.exe main.cpp
g++ -Oz -o main_Oz.exe main.cpp

# Запуск каждого варианта
./main_O0.exe
./main_O1.exe
./main_O2.exe
./main_O3.exe
./main_Os.exe
./main_Oz.exe
```

### 4. Анализ машинного кода (опционально)

```bash
# Автоматический анализ ассемблерного кода
python analyze_assembly.py

# Или вручную:
g++ -O2 -S -fverbose-asm -o main_O2.s main.cpp
# Просмотр файла main_O2.s
```

## Уровни оптимизации

- **-O0**: Без оптимизации
- **-O1**: Базовая оптимизация
- **-O2**: Агрессивная оптимизация (рекомендуется)
- **-O3**: Максимальная оптимизация
- **-Os**: Оптимизация по размеру
- **-Oz**: Максимальная оптимизация по размеру

## Ожидаемые результаты

1. **Correct hint** должен показывать лучшую производительность на высоких уровнях оптимизации
2. **Wrong hint** должен показывать худшую производительность
3. **Inverted hint** должен показывать результаты близкие к baseline
4. На низких уровнях оптимизации (-O0, -O1) разница должна быть минимальной

## Файлы

- `main.cpp` - основной код программы
- `run_benchmark.py` - автоматический бенчмарк с графиками
- `analyze_assembly.py` - анализ машинного кода
- `compile_and_run.bat` - batch-скрипт для Windows
- `analyze_results.py` - простой анализатор результатов
- `README.md` - данная инструкция

## Выходные файлы

После запуска бенчмарка создаются:
- `benchmark_results.png` - графики сравнения
- `benchmark_results.json` - данные в JSON формате
- `main_*.exe` - исполняемые файлы для каждого уровня оптимизации
- `main_*.s` - ассемблерные файлы (при анализе машинного кода)

## Требования

- GCC или совместимый компилятор
- Python 3.x с matplotlib (для анализа результатов)
- Windows (для корректного отображения русского языка)

## Пример вывода

```
=======================================================

Размер массива 500000000 элементов
=== Результаты (усреднённое время из 3 запусков) ===

1) Baseline (без подсказок):
   Time = 0.235399 с,  sum_many = 250009244854, sum_rare = 250178901

2) Верная подсказка (unlikely(i%1000==0)):
   Time = 0.237596 с,  sum_many = 250009244854, sum_rare = 250178901

3) Неверная подсказка (likely(i%1000==0)):
   Time = 0.312232 с,  sum_many = 250009244854, sum_rare = 250178901

4) Инвертированная «перевернутая» подсказка:
   Time = 0.315115 с,  sum_many = 250009244854, sum_rare = 250178901

=======================================================
```

## Интерпретация результатов

- **Baseline**: базовое время выполнения без оптимизаций
- **Correct hint**: должно быть быстрее baseline на высоких уровнях оптимизации
- **Wrong hint**: должно быть медленнее baseline из-за неправильной подсказки
- **Inverted hint**: должно быть близко к baseline

Разница в производительности наиболее заметна на уровнях -O2 и -O3, где компилятор активно использует подсказки о вероятности ветвлений. 